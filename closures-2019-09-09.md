Closures
========

*Topics/tags: [The joy of code](index-joc), technical*

Yesterday, I was [musing about new programming languages I might
learn and how I might learn them](new-languages-2019-09-08).  Along
the way, I mentioned that I like to explore closures in the new
functional languages I learn.  What's a closure?  Here's what
[Wikipedia](https://en.wikipedia.org/wiki/Closure_(computer_programming))
says,

> In programming languages, a *closure*, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions. Operationally, a closure is a record storing a function together with an environment. The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created. Unlike a plain function, a closure allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope. 

Here's an examples of one kind of closure I might write in Racket [1].

```
> (define counter
    (lambda (init)
      (let ([count init])
        (lambda ()
          (let ([temp count])
            (set! count (+ 1 count))
            temp)))))
> (define c1 (counter 1))
> (c1)
1
> (c1)
2
> (c1)
3
> (c1)
4
> (define c2 (counter 1))
> (c2)
1
> (c1)
5
```

What does this code snippet reveal?  First, it shows that a function
can refer to variables in its enclosing scope even after that scope
has finished.  That is, although `count` is declared in `counter`,
and the call to `counter` has terminated when we call `c1`, `c1`
can still access `count`.  Second, it shows that each function we
create with `counter` has its own copy of `count`.

I recall having trouble achieving that behavior when I first learned
Python.  While I know that Python now implements closures, I'm still
having trouble figuring out the details of how to do just that.
The sample Python code on [the Wikipedia
page for closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)) 
claims to implement closures.  Here's an excerpt:

```
def f(x):
    def g(y):
        return x + y
    return g  # Return a closure.
a = f(1)
assert a(5) == 6
```

I had written something like that as I was thinking about closures in
Python.  Here's my version, taken from an interactive Python interpreter.

```
>>> def make_adder(x):
...   def adder(y):
...     return x+y
...   return adder
... 
>>> add3 = make_adder(3)
>>> add5 = make_adder(5)
>>> add3(2)
5
>>> add5(2)
7
```

Mine differs in that I've tried to assign more sensible names to
the two function and that I've tried to demonstrate that each new
function returned by `make_adder` has an independent version of
`x`.

However, I'm not sure that this is really a closure.  That behavior
seems to be achievable with a strategy less powerful than what I
think of as closures, since it does not permit mutation of the
variable in the enclosed environment.  In particular, we need not
need to keep track of the `x`; we can simply translate the `x` to
its value in building the body.  Or maybe that's enough; perhaps I
don't understand closures well enough.

In any case, here's my first attempt at Python code with mutation,
a manual "translation" of my Racket code to Python.

```
>>> def counter(init):
...   count = init
...   def fun():
...     temp = count
...     count = count + 1
...     return temp
...   return fun
```

Unfortunately, this version does not work.  Can you tell why?  Let's
see.

```
>>> c1 = counter(1)
>>> c1()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 4, in fun
UnboundLocalError: local variable 'count' referenced before assignment
```

Some poking around suggests that I could try `nonlocal`.  Let's see if
that works.

```
$ python
Python 2.7.8 (v2.7.8:ee879c0ffa11, Jun 29 2014, 21:07:35) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> def counter(init):
...   count = init
...   def fun():
...     nonlocal count
  File "<stdin>", line 4
    nonlocal count
                 ^
SyntaxError: invalid syntax
```

Whoops.  I guess `nonlocal` is only available in Python3.  My next 
inclination was to make `x` a mutable object and see if I can mutate
it.  My further research about `nonlocal` and closures in Python2
revealed the following [useful snipect from StackOverflow](https://stackoverflow.com/questions/3190706/nonlocal-keyword-in-python-2-x) [2].

> Inner functions can _read_ nonlocal variables in 2.x, just not _rebind_ them. This is annoying, but you can work around it. Just create a dictionary, and store your data as elements therein. Inner functions are not prohibited from _mutating_ the objects that nonlocal variables refer to.

> To use the example from Wikipedia:

>     def outer():
>       d = {'y' : 0}
>       def inner():
>           d['y'] += 1
>           return d['y']
>       return inner
>
>     f = outer()
>     print(f(), f(), f()) #prints 1 2 3

And yes, that example works as anticipated.  It even works when we
create two separate counters.

```
>>> f = outer()
>>> print(f(), f(), f())
(1, 2, 3)
>>> g = outer()
>>> print(f(), f(), f())
(4, 5, 6)
>>> print(g(), g(), g())
(1, 2, 3)
>>> print(f(), f(), f())
(7, 8, 9)
>>> print(g(), g(), g())
(4, 5, 6)
>>> f = outer()
>>> print(f(), f(), f()) 
(1, 2, 3)
>>> print(g(), g(), g())
(7, 8, 9)
```

But that's not a closure.  That's a manual implementation of environments.
What's the difference?  First, it's something that the programmer has to
do, rather than the language.  Second, it's not as generalized as closures.
With simple nesting, this approach works okay.  However, closures work even
if we have much deeper nesting of functions.  That would require significantly
more effort on the part of the programmer if we were to use the "manual
environment" approach [3].

Given what I've found, I'd have to say that Python2 does not have closures,
at least not what I think of as closures.

In [yesterday's musing](new-languages-2019-09-08), I identified
closures as one of the things I play with when I learn a new language.
I'm trying to learn Kotlin.  Perhaps I should try to figure out 
closures in Kotlin.

More to come!

---

Postscript: I realize that some folks would say "Closures are a
stupid way to achieve the counter behavior that you are describing
in this musing."  I might even agree.  But the counters provide a
simple example of what closures are; there are more complex situations
that benefit from more complex use of closures.  It's kind of like
recursion.  Many of the recursive procedures we first consider could
be written iteratively.  But consider Quicksort [4,6].  Can you
write Quicksort iteratively without a stack?  I'm not sure that I
can.  And, in the end, the implicit stack given by recursion is
much easier to manage than an explicit stack.

---

Postscript: I'd love to hear from one of my colleagues in Programming
Languages whether they consider the Python 2 version of closures
"real closures".

---

[1] Would I really write code with side-effects in Racket?  Sure, when
it seems appropriate.

[2] I generally tell my students to be cautious about what they take from
StackOverflow.  For example, the advice to use ArrayLists in Java appears
way too often.  But that doesn't mean that everything on StackOverflow
is pointless.

[3] It could also generate much slower code.

[4] Quicksort is a famous probabilistic "divide and conquer" sorting
routine developed [5] by C.A.R. "Tony" Hoare.  It involves reordering
an array or subarray so that "small" elements are on the left and
"large" elements are on the right, and then recursing on each part.

[5] Discovered?

[6] There seem to be multiple spellings of "Quicksort", including
"Quick sort", "Quick Sort", "QuickSort", and even "quik sort".  I
stick with Hoare's spelling.

[7]  There seem to be at least two early articles by Hoare on Quicksort.

>  C. A. R. Hoare. 1961. Algorithm 64: Quicksort. *Commun. ACM* 4, 7 (July 1961), 321-. DOI=10.1145/366622.366644 <http://doi.acm.org/10.1145/366622.366644>

>  C. A. R. Hoare. 1962. Quicksort. (Comput. J.* 5, 1, 10â€“16. doi:10.1093/comjnl/5.1.10 <http://comjnl.oxfordjournals.org/content/5/1/10.full.pdf>

---

*Version 0.1 of 2019-09-08.*
